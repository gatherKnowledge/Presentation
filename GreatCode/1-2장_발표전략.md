##### 1 ~ 2장

1. 렌달 하이드의 Great Code에 관한 간략한 소개, 어떤 사람인지
영어 부제, UNDERSTANDING THE MACHINE
2. 수와 수치 표기법, 개념 설명
3. 컴퓨터 상에서 이용되는 진법 2진법, 16진법, 8진법
    * 어떤 진법을 사용했어도 결국 컴파일러에서 2진수로 수정을 한다.
4. 비트, 두가지만 정확히 표현할 수 있다. 이 한계를 벗어나기 위한 비트 스트링
    * 특별히 인텔에서 사용하는 데이터단위 tbyte, bcd,부동소수점 표기를 위해
    * tbyte 디렉티브에 관한 변환 알고리즘
    > 사이에 일반 데이터 형 몇 가지를 넣어주고 그 다음 부호 있는 수와 부호 없는 수에 대한 내용을 하는것이 더 매끄러울 듯.

5-0. 부호 있는 수, 부호 없는 수의 차이 그리고 변환하는 알고리즘    
5. 음수(부호 있는 수)를 변환하는 알고리즘
    * 넣을 지 말지 고민
6. 부호 확장, 부호 축소 - 형변환
6-1. 부호확장 부호 축소하는 알고리즘 C 코드

7. 포화
7-1. 포화 알고리즘 C 코드

8. 2진화 10진 표기법의 장점과 단점 - BCD코드

9. 고정 소수점 표기, 일반적으로 알고 있는 부동소수점 표기법과 다른점은 무엇인지.

10. 스케일 수 표기법
10-1. 예시 C 코드

11. 유리수 표기법
11-1. 예시 C 코드


---
--> 총 목차는 4개로 줄이기!
1. 수와 수치 표기법
2. 진법
3. 컴퓨터 저장 단위
4. 여러가지 표기법

---

[키노트]
 - 발표 시작하겠습니다. 제가 오늘부터 발표하게 될 내용은 렌달 하이드 저자의 GreatCode 라는 책을 주제로 발표하게 됐습니다. 책은 두 권으로 나눠져 있고 첫 번째 책은 하드웨어를 주제로 한 원제 understanding the machine  
이라는 책입니다. 두 번째 책은 코드가 컴파일러를 통해 기계어 코드가 됐을 때의 레벨에서 설명을 합니다. 우리가 흔히 사용하는 자료 구조나 상수, 변수가 실제로는 어떻게 표현되는지, 연산이나 제어 구조가 기계어로는 어떻게 구현되는지, 컴파일러는 어떤 식으로 최적화를 수행하는지. 즉 효율적인 코드 작성에 대한 이야기를 합니다. 앞으로 PPT는 한 챕터 당 분량이 많은 관계로 챕터 단위로 발표할 예정입니다. 자 우선, 목차 입니다.

[1 Chapter]
<1, 2 목차>
수와 수체계의 개념, 수는 막연하고 추상적이며, 또 개념적인 내용인 동시에 양을 나타내는 지적 도구이고 수체계는 그 개념을 표현하기 위한 도구. 100, 64(16), 0110 0100(2), 백 --> 나열 된 것들은 모습은 다르지만 모두 같은 양의 개념을 설명한다는 것.
이런 수치 표현은 이제 실제 알고리즘등을 정확하고 효과적으로 동작하기 위해 의존하는데 이론적인 의미의 수와 수치 표기법에 대한 차이를 이해하지 못한다면, 알고리즘을 이해하고 사용하고 만드는 데 큰 어려움을 겪게 될 것이다.
예를 들어 무인도가서 하루 지나 갈 때마다 바위에다가 체크 하잖아요? 이 표기법을 하나씩 체크하는 것을 산가지 표기법이라고 하는데, 잔가지 표기법을 이용해서 만드는 알고리즘과 이진법을 이용해서 만드는 알고리즘의 성능은 크게 차이가 날 것이다. 그래서 이 수와 수치표기법에 대해 정확히 아는 것은 여러가지 알고리즘을 쉽게 해결 해 줄 수 있는 해결책이 될 수 있다. 잘 알고있으면 상황에 맞는 수체계를 쓸 수 있으니, 더 효율적으로 알고리즘을 만들 수 있겠죠? 여러분이 지금 공부하고 계시는 자료구조, 내가 큐를 써야 하는데 스택 구조를 사용해서 처리했다고 해봅시다. 일일이 집어넣고 뒤집어 주고하는 일련의 작업을 한 작업으로 처리해야 할 수 있다. 좀 더 크게 나가면 자료구조 역시도 수치표기로 볼 수 있다.


~~1권은 하드웨어 레벨에서의 이야기, 2권은 코드가 컴파일러를 거쳤을 때의 기계어 코드에 대해서 설명합니다. 즉 효율적인 코드 작성에 대한 얘기를 하겠죠. 고급언어로 작성된 소스 코드가 컴파일러를 거쳐 어떤 식의 기계어 코드로 바뀌는지에 대해 집중적으로 다루고 있다. 우리가 흔히 사용하는 자료 구조나 상수, 변수가 실제로는 어떻게 표현되는지, 연산이나 제어 구조가 기계어로는 어떻게 구현되는지, 컴파일러는 어떤 식으로 최적화를 수행하는지~~

10진 위치 표기법을 먼저 설명할텐데, 일련의 아라비아 숫자들을 이용해서 표기하는데 [그림2-2] 보시는데로 각 위치는 10의 자리수 별로 표현하는 방법입니다. 이를 이용하면 산가지법에 비해서 각 자리는 각 자리 별로 1/3, 1/30, 1/300을 표현 할 수 있습니다. 한 가지 더 이야기 하자면 산가지 표기법으로는 실수표현을 할 수 없겠죠? 얘 같은 경우에는 말끔하게 표현 할 수 있지만
10을 멱수로 10개의 심볼을 사용하는 방법. 그렇다면 이와 같은 방법으로 2진법, 8진법, 16진법.. 10을 넘는 표기들은 기타 기호들에 맞춰서 매칭시키면 되고.. 쓸 수 있을 것이다. 8진법의 경우에는 오래 된 시스템에서 유행했던 시스템으로 이 세가지 표기법은 서로 익숙해져야 한다.
16진법으로 2진수를 표현할 때와 8진법으로 2진수를 표현할 때의 자리 수 차이

<3장 컴퓨터 상에서 사용되는 진법>
비쥬얼 베이직의 경우 &hdead
파스칼 언어(델파이,카일릭스)의 경우 $dead
hal의 경우 파스칼과 마찬가지로, 그리고 얘는 다시 한 번 네 자리마다 언더스코어를 써서 표기해준다
각종 진법에 대한 설명 base수를 기준으로 설명하는 것. n진법이라면 0~(n-1)을 표기하는 방법
8진법 컴퓨터도 있었다는 이야기.. 역시 일찍부터 사용됐던 컴퓨터 시스템이라고 한다. 지금 linux에서도 사용되고 있는 파일 권한에 대한 처리를 777로 하는 것 역시 8진 표기법의 흔적이라고 볼 수 있다. 여러 가지 진법을 제어하기 위해 여러가지 진법이 있었지만 지금도 힘든 전압 제어를 과거에  대로 했을 리 만무, 아마 많은 점에서 문제가 생겼었을 것이다. 그래서 결국 0v l, 3.3v h/ 0v l, 5v h 시스템으로 굳혀져 2진시스템으로 굳혀졌을 것입니다.
만약이지만, 우리가 지금 썼거나 지금 쓰고 있는 2,4,8,16,32,64비트 체계로 넘어갔던 것이 아니고 3배수 단위로 넘어갔을 것이다. 48비트 컴퓨터, 96비트 컴퓨터 체계를 쓰고 있었을 수도 있다. 수십년에 거쳐 쇠퇴했다고 함. 오래된 유닉스 프로그램에서 8진법을 사용한 것을 볼 수 있다. 8진법의 경우에는 접미사로 O를 쓰는 것이 아니고 Q를 사용하는데 이는 숫자 0과의 혼동을 피하기 위해서 사용된 것으로 추측 할 수 있겠다. 2진법을 표현할 때 책에서는 두 가지 언어를 사용하는데, 2진법임을 표현하기위해 masm을 쓴 경우에는 마지막 자리 수에 b를 더하고, high level assembler를 이용한 경우에는 %를 접두어에 붙혀서 사용

>수의 문자 변환에 대한 비용, 대부분의 언어들이 너무나 쉽게 사용할 수 있는 이런 기능들을 제공하는데, 비용에 대해서 알지 못 한다면 제대로 프로그램을 만들 수 없다.

<4장 컴퓨터 데이터 저장의 기본 단위>
비트, 켜짐과 꺼짐, 남성과 여성, 빨강과 파랑
bit이야기, byte이야기, 워드, 더블워드, 쿼드로플 워드 등이 있다. 내용 추가
인텔 masm의 경우에는 tbyte 디렉티브를 지원하는데 10바이트의 저장장소에 압축 이진부호화 십진수 정수를 저장한다.
최상위 바이트를 제외한 각 바이트는 십진수 두자리를 저장한다. 최상위바이트의 최상위 비트는 당연히 부호비트로 활용된다. 80이상이 되면 음수가 되는 것. 표현할 수 있는 범위는 당연히 20개인데 마지막 니블의 첫번째는 부호비트로 사용되니까
비트 그림 그려서 설명. 리틀엔디안 인 것으로 농락
부호 있는 수에 대한 알고리즘을 설명할까 말까? 고민..
부호 확장, 부호 축소 흔히 고급언어에서 사용하고 있는 형변환이 내부적으로 이뤄지는 동작.
명령어 cbw(byte to word), cwd(word to doubleword), cwde(word to extented doubleword), cdq(doubleword to quadword) 우리가 x86에서 공부하면서 배웠던 명령어 들 일 것입니다. 부호 있는 수는 있으면 1 음수가 아니면 0으로 동작하는 알고리즘을 가지고 있기 때문에, 굳이 부호없는 수에서 다른 알고리즘을 사용할 필요는 없다.
문제는 축소 연산인데, 부호 축소를 시키고 싶다면 먼저 버려지는 상위 바이트를 확인해야 할 것이다. 모두 0이거나 FF여야지 아니라고 한다면 값의 변경이 일어날 것이다. C와 같은 언어에서는 단순히 하위 데이터 영역을 남기고 상위 데이터 부분을 제거함으로 축소를 실행하기도한다. .. 검증할 수 있는 실제 C코드

<5장 부호 있는 수와 부호 없는 수>
<6장 2진수의 유용한 특성>
<7장 부호 확장과 축소>
확장과 축소를 알아야 하는 이유, 공통코드로 자동으로 추가하거나 컴파일러가, 에러를 내뱉을 수 있는데 특히 자동으로 추가하게 되면 비용을 소모하게 되는 것 이므로
C언어에서는 이를 명시적으로 선언해주지 않아도, 자동으로 형변환을 시켜주는데 이에 관한 코드 (Asm코드로)
축소의 경우에는 H쪽 비트가 모두 0 이거나 1이거나 해야 하는데 그렇지 않으면 당연하게도. 확장 했다가 축소 했는데 서로 다른 값이 나오면 말도 안 되지. C언어 같은 경우에는 그냥 상위 바이트 부분을 제거하는 식으로 컨트롤 컴파일러가 에러를 뱉지는 않고 단순히 경고만 내려준다. 특히 우리가 배운 터보C의 경우에는 이 값을 확인 할 수 있는 지시어를 사용할 수도 있다고.


<7장 포화>
부호 축소의 특별한 경우로 볼 수 있는데
포화.. 큰 데이터 형에서 작은 데이터 형으로 변환하는 것. 약간은 어처구니가 없을 수 있는 작업변환하려는 작은 범위에서 나타낼 수 있는 범위라고 하면 그대로 표현하게 되고 그 이상을 표현해야 한다고하면 그 데이터 단위 사이에서 나타낼 수 있는 가장 큰 혹은 가장 작은 크기의 데이터를 명시한다.
부호 축소와 다른 점은 앞을 띠어 내는 것이고 포화의 경우에는 표현할 수 잇는 크기를 벗어난다면 모든 비트를 '1'로 표시한 다는 것, 이를 표현하는 소스 코드 첨부

<8장 BCD코드>
이진표기법으로는 1.3과 같은 수는 정확히 표현 할 수 없다. 한 없이 가까운 값을 표기하는 것, 하지만 BCD코드의 경우에는 가능하다. 데이터 비트의 손해만 감수한다면.
각 가중치의 크기대로 8421코드라는 이름을 붙혀 부르기도 한다.
단점의 경우에는 매 자리 수 마다 이진수 표기법에 비해서 6개의 수를 손해 본다는 것. 그래서 이 값을 보정해주기 위해서 자리 올림이 일어났을 때 자리 올림 수 +6을 진행해 보정을 한다. 나머지 수는 10~15를 표기하는 것은 무효코드라고 해서 사용되지 않는 코드이다. BCD의 경우 손해가 많은 언어이다 단점으로는 이진수 8비트로 표현할 수 있는 수가 256가지인데 비해 겨우 두가지수까지 표현 100개 밖에 표현 못함 또 계산할 때 변환하는 과정이 필요. [소스코드]
하지만 수 표기와 십진 문자표기법과의 전환이 쉬움. 토스트 라던지 전자레인지에서 편하게 사용 될 수 있다. 7세그먼트 같은 것들을 사용하는데 어차피 각 자리만 표현해주면 되는 것이기 때문에. [그림첨부]


<9장 고정소수 표기>
소수점 이하의 표현에서 핵심은 얼마나 많은 비트를 사용해서 최대한 그 값에 가깝게 표현 해 줄 수 있는 것이냐가 포인트 인데, 남는 비트들을 효과적으로 사용 할 수가 없다. 하지만 과거의 부동 소수점 표현을 하드웨어가 지원하지 않던 시절에서 대부분 소프트웨어로 구현해서 쓰던 방법이다.

 부동소수점표기의 경우에는 10의 지수를 통해서 점의 위치가 바뀌는데 고정소수 표기의 경우에는 이 소수점의 위치가 고정 돼 있다.
 부동 소수점 의 표현 방식은 (가수)×(밑수)^(지수)의 형태에서 밑수 만이 고정되고 지수값을 서술하는 별도의 비트 영역을 할당 해 두는 방식이다. 이러한 방식은 숫자를 표현하는데에 있어서 일정한 유효숫자를 보장한다는 장점이 있다. 반면에 고정 소수점 방식은 밑수 뿐 아니라 지수 값도 미리 결정 해 두고 사용하는 방식이다. 따라서 정수형 자료형을 기반으로 소수점을 표현할 수 있다. 연산 장치에 따라서 부동 소수점을 지원하지 않는 경우에는 이러한 방식으로 소수점을 표현하여아 한다. 또한, 정수형 자료형의 연산은 부동소수점 자료형의 연산보다 빠르게 할 수 있다는 장점이 있다. 연산 절차 상으로는 부동 소수점은 곱셈이 간편하고, 고정 소수점은 덧셈/뺄셈이 간편하다는 차이를 보인다.
 정리 --> 동일한 데이터 크기를 가지고 있을 때 표현 할 수 있는 범위가 넓고, 곱셈 연산에 강하다.

 <10장 스케일 수 표기법>
scaled numeric formats, 실수부의 정확한 수치 값, 2진 포멧의 정밀함을 모두 갖는 표기법이 존재 한다. 그것이 스케일 수치 표기법. 모든 값을 정수부 연산으로 변환해서 계산 할 수 있다는 장점을 가지고 있다. 덧셈에서는 문제가 되지 않지만 곱셈이나 나눗셈의 경우에는 스케일 팩터라는 값을 다시 한 번 보정을 취해줘야 한다.
..결론 곱셈과 나눗셈을 할 경우에는 나타낼 수 있는 수의 쟈ㅔ한이 생긴다 피제수를 스케일 팩터인 100만큼 미리 곱해야 한다면 피제수는 사용가능한 최대 정수값의 1/100이하여야 한다 그렇지 않으면 오버플로우가 발생하게 되는데 이러한 문제 대문에 스켕ㄹ 수치 표ㅣ법을 사용할 때는 필요 이상으로 큰 데이터 형을 사용해야 하거나 사용하는 수의 크기에 제한이 생길 수 있다.

 <11장 유리수 표기법>
 한 쌍의 정수를 통해서 n/d의 표현식을 만드는 것, 하지만 역시 유리수 표기법의 유일한 문제점은 어던 경우 분자값이나 분모값이 오버플로우가 발생할 정도로 너무 커질 수 있다는 것이다. 이런 문제점만 빼면 유리수 ㅛ기법을 사용해서 매우 넓은 범위의 소수값을 정확하게 표현할 수 있다. 유리수의 정의.
 정수의 비로 나타낼 수 있는 수. 정수 및 분수를 합쳐서 부름. 유리수는 소수로 나타내면 유한 소수나 순환 소수의 어느 것이 됨.
