##### 1 ~ 2장

1. 렌달 하이드의 Great Code에 관한 간략한 소개, 어떤 사람인지
영어 부제, UNDERSTANDING THE MACHINE
2. 수와 수치 표기법, 개념 설명
3. 컴퓨터 상에서 이용되는 진법 2진법, 16진법, 8진법
    * 어떤 진법을 사용했어도 결국 컴파일러에서 2진수로 수정을 한다.
4. 비트, 두가지만 정확히 표현할 수 있다. 이 한계를 벗어나기 위한 비트 스트링
    * 특별히 인텔에서 사용하는 데이터단위 tbyte, bcd,부동소수점 표기를 위해
    * tbyte 디렉티브에 관한 변환 알고리즘
    > 사이에 일반 데이터 형 몇 가지를 넣어주고 그 다음 부호 있는 수와 부호 없는 수에 대한 내용을 하는것이 더 매끄러울 듯.

5-0. 부호 있는 수, 부호 없는 수의 차이 그리고 변환하는 알고리즘    
5. 음수(부호 있는 수)를 변환하는 알고리즘
    * 넣을 지 말지 고민
6. 부호 확장, 부호 축소 - 형변환
6-1. 부호확장 부호 축소하는 알고리즘 C 코드

7. 포화
7-1. 포화 알고리즘 C 코드

8. 2진화 10진 표기법의 장점과 단점 - BCD코드

9. 고정 소수점 표기, 일반적으로 알고 있는 부동소수점 표기법과 다른점은 무엇인지.

10. 스케일 수 표기법
10-1. 예시 C 코드

11. 유리수 표기법
11-1. 예시 C 코드


---
--> 총 목차는 4개로 줄이기!
1. 수와 수치 표기법
2. 진법
3. 컴퓨터 저장 단위
4. 여러가지 표기법

---

[키노트]
 - 발표 시작하겠습니다. 제가 오늘부터 발표하게 될 내용은 렌달 하이드 저자의 GreatCode 라는 책을 주제로 발표하게 됐습니다. 책은 두 권으로 나눠져 있고 첫 번째 책은 하드웨어를 주제로 한 원제 understanding the machine  
이라는 책입니다. 두 번째 책은 코드가 컴파일러를 통해 기계어 코드가 됐을 때의 레벨에서 설명을 합니다. 우리가 흔히 사용하는 자료 구조나 상수, 변수가 실제로는 어떻게 표현되는지, 연산이나 제어 구조가 기계어로는 어떻게 구현되는지, 컴파일러는 어떤 식으로 최적화를 수행하는지. 즉 효율적인 코드 작성에 대한 이야기를 합니다. 앞으로 PPT는 한 챕터 당 분량이 많은 관계로 챕터 단위로 발표할 예정입니다. 자 우선, 목차 입니다.

[1 Chapter]
<1, 2 목차>
~~1권은 하드웨어 레벨에서의 이야기, 2권은 코드가 컴파일러를 거쳤을 때의 기계어 코드에 대해서 설명합니다. 즉 효율적인 코드 작성에 대한 얘기를 하겠죠. 고급언어로 작성된 소스 코드가 컴파일러를 거쳐 어떤 식의 기계어 코드로 바뀌는지에 대해 집중적으로 다루고 있다. 우리가 흔히 사용하는 자료 구조나 상수, 변수가 실제로는 어떻게 표현되는지, 연산이나 제어 구조가 기계어로는 어떻게 구현되는지, 컴파일러는 어떤 식으로 최적화를 수행하는지~~

<3장 컴퓨터 상에서 사용되는 진법>
각종 진법에 대한 설명 base수를 기준으로 설명하는 것. n진법이라면 0~(n-1)을 표기하는 방법
8진법 컴퓨터도 있었다는 이야기.. 역시 일찍부터 사용됐던 컴퓨터 시스템이라고 한다. 지금 linux에서도 사용되고 있는 파일 권한에 대한 처리를 777로 하는 것 역시 8진 표기법의 흔적이라고 볼 수 있다. 여러 가지 진법을 제어하기 위해 여러가지 진법이 있었지만 지금도 힘든 전압 제어를 과거에 제대로 했을 리 만무, 아마 많은 점에서 문제가 생겼었을 것이다. 그래서 결국 0v l, 3.3v h/ 0v l, 5v h 시스템으로 굳혀져 2진시스템으로 굳혀졌을 것입니다.
만약이지만, 우리가 지금 썼거나 지금 쓰고 있는 2,4,8,16,32,64비트 체계로 넘어갔던 것이 아니고 3배수 단위로 넘어갔을 것이다. 48비트 컴퓨터, 96비트 컴퓨터 체계를 쓰고 있었을 수도 있다. 수십년에 거쳐 쇠퇴했다고 함. 오래된 유닉스 프로그램에서 8진법을 사용한 것을 볼 수 있다. 8진법의 경우에는 접미사로 O를 쓰는 것이 아니고 Q를 사용하는데 이는 숫자 0과의 혼동을 피하기 위해서 사용된 것으로 추측 할 수 있겠다.

<4장 컴퓨터 데이터 저장의 기본 단위>
bit이야기, byte이야기, 워드, 더블워드, 쿼드로플 워드 등이 있다. 내용 추가
인텔 masm의 경우에는 tbyte 디렉티브를 지원하는데 10바이트의 저장장소에 압축 이진부호화 십진수 정수를 저장한다.
최상위 바이트를 제외한 각 바이트는 십진수 두자리를 저장한다. 최상위바이트의 최상위 비트는 당연히 부호비트로 활용된다. 80이상이 되면 음수가 되는 것. 표현할 수 있는 범위는 당연히 20개인데 마지막 니블의 첫번째는 부호비트로 사용되니까
비트 그림 그려서 설명. 리틀엔디안 인 것으로 농락

부호 있는 수에 대한 알고리즘을 설명할까 말까? 고민..
부호 확장, 부호 축소 흔히 고급언어에서 사용하고 있는 형변환이 내부적으로 이뤄지는 동작.
명령어 cbw(byte to word), cwd(word to doubleword), cwde(word to extented doubleword), cdq(doubleword to quadword) 우리가 x86에서 공부하면서 배웠던 명령어 들 일 것입니다. 부호 있는 수는 있으면 1 음수가 아니면 0으로 동작하는 알고리즘을 가지고 있기 때문에, 굳이 부호없는 수에서 다른 알고리즘을 사용할 필요는 없다.
문제는 축소 연산인데, 부호 축소를 시키고 싶다면 먼저 버려지는 상위 바이트를 확인해야 할 것이다. 모두 0이거나 FF여야지 아니라고 한다면 값의 변경이 일어날 것이다. C와 같은 언어에서는 단순히 하위 데이터 영역을 남기고 상위 데이터 부분을 제거함으로 축소를 실행하기도한다. .. 검증할 수 있는 실제 C코드

---
<7장 포화>
포화.. 큰 데이터 형에서 작은 데이터 형으로 변환하는 것. 약간은 어처구니가 없을 수 있는 작업변환하려는 작은 범위에서 나타낼 수 있는 범위라고 하면 그대로 표현하게 되고 그 이상을 표현해야 한다고하면 그 데이터 단위 사이에서 나타낼 수 있는 가장 큰 혹은 가장 작은 크기의 데이터를 명시한다.
부호 축소와 다른 점은 앞을 띠어 내는 것이고 포화의 경우에는 표현할 수 잇는 크기를 벗어난다면 모든 비트를 '1'로 표시한 다는 것.

<8장 BCD코드>
이진표기법으로는 1.3과 같은 수는 정확히 표현 할 수 없다. 한 없이 가까운 값을 표기하는 것, 하지만 BCD코드의 경우에는 가능하다. 데이터 비트의 손해만 감수한다면.
각 가중치의 크기대로 8421코드라는 이름을 붙혀 부르기도 한다.
단점의 경우에는 매 자리 수 마다 이진수 표기법에 비해서 6개의 수를 손해 본다는 것. 그래서 이 값을 보정해주기 위해서 자리 올림이 일어났을 때 자리 올림 수 +6을 진행해 보정을 한다. 나머지 수는 10~15를 표기하는 것은 무효코드라고 해서 사용되지 않는 코드이다.
수 표기와 십진 문자표기법과의 전환이 쉽다.
(참고 유니코드, 최대로 수용할 수 있는 문자수는 16비트=65,536자이며, 이중 38,885자는 이미 주요 국가의 언어를 구현하는데 할당되었고, 6,400자는 사용자 정의 영역으로, 나머지 20,000여 자는 새로 추가될 언어 영역으로 각각 비워두고 있다. 각국의 문자를 2바이트로 수용하기 위해 한국, 중국, 일본, 타이완의 한자를 통합하였다. 7비트 까지의 숫자들은 영어, 비영어는 8비트, 한글이나 일본어는 16비트의 값을 가지고 있다.)

<9장 고정소수 표기>
 부동소수점표기의 경우에는 10의 지수를 통해서 점의 위치가 바뀌는데 고정소수 표기의 경우에는 이 소수점의 위치가 고정 돼 있다.
 부동 소수점 의 표현 방식은 (가수)×(밑수)^(지수)의 형태에서 밑수 만이 고정되고 지수값을 서술하는 별도의 비트 영역을 할당 해 두는 방식이다. 이러한 방식은 숫자를 표현하는데에 있어서 일정한 유효숫자를 보장한다는 장점이 있다. 반면에 고정 소수점 방식은 밑수 뿐 아니라 지수 값도 미리 결정 해 두고 사용하는 방식이다. 따라서 정수형 자료형을 기반으로 소수점을 표현할 수 있다. 연산 장치에 따라서 부동 소수점을 지원하지 않는 경우에는 이러한 방식으로 소수점을 표현하여아 한다. 또한, 정수형 자료형의 연산은 부동소수점 자료형의 연산보다 빠르게 할 수 있다는 장점이 있다. 연산 절차 상으로는 부동 소수점은 곱셈이 간편하고, 고정 소수점은 덧셈/뺄셈이 간편하다는 차이를 보인다.
 정리 --> 동일한 데이터 크기를 가지고 있을 때 표현 할 수 있는 범위가 넓고, 곱셈 연산에 강하다.

 <10장 스케일 수 표기법>
scaled numeric formats, 실수부의 정확한 수치 값, 2진 포멧의 정밀함을 모두 갖는 표기법이 존재 한다. 그것이 스케일 수치 표기법. 모든 값을 정수부 연산으로 변환해서 계산 할 수 있다는 장점을 가지고 있다. 덧셈에서는 문제가 되지 않지만 곱셈이나 나눗셈의 경우에는 스케일 팩터라는 값을 다시 한 번 보정을 취해줘야 한다.
..결론 곱셈과 나눗셈을 할 경우에는 나타낼 수 있는 수의 쟈ㅔ한이 생긴다 피제수를 스케일 팩터인 100만큼 미리 곱해야 한다면 피제수는 사용가능한 최대 정수값의 1/100이하여야 한다 그렇지 않으면 오버플로우가 발생하게 되는데 이러한 문제 대문에 스켕ㄹ 수치 표ㅣ법을 사용할 때는 필요 이상으로 큰 데이터 형을 사용해야 하거나 사용하는 수의 크기에 제한이 생길 수 있다.

 <11장 유리수 표기법>
 한 쌍의 정수를 통해서 n/d의 표현식을 만드는 것, 하지만 역시 유리수 표기법의 유일한 문제점은 어던 경우 분자값이나 분모값이 오버플로우가 발생할 정도로 너무 커질 수 있다는 것이다. 이런 문제점만 빼면 유리수 ㅛ기법을 사용해서 매우 넓은 범위의 소수값을 정확하게 표현할 수 있다. 유리수의 정의.
 정수의 비로 나타낼 수 있는 수. 정수 및 분수를 합쳐서 부름. 유리수는 소수로 나타내면 유한 소수나 순환 소수의 어느 것이 됨.
